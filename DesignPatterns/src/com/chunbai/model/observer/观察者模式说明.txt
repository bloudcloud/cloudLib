1. 观察者模式概念
   观察者模式又称作发布-订阅(publish/Subscribe)、模型-视图(model/view)、源-监听器(source/listener)或从属者(Dependents)模式。
   用来定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新
   Observable(抽象被观察者角色)：定义了被观察者必须实现的职责，它必须能够动态地增加、删除观察者，并且通知观察者。
   Observer(抽象观察者角色)：定义了观察者收到消息后，进行更新的接口。
   ConcreteObservable(具体被观察者角色)：定义了被观察者自己的业务逻辑，并且定义了对哪些事件进行通知。
   ConcreteObserver(具体观察者角色)：实现更新接口，对通知按自己的需求处理。
	
   这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来看作事件处理系统。
   观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
   这个主题对象(发布者对象)在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
   将一个系统分割成一系列相互协作的类有一个很不好的习惯，那就是需要维护相关对象间的一致性。
   我们不希望为了维护一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
   
   当一个对象的改变需要同时改变其他对象的时候，而且不知道具体有多少对象有待改变时，我们考虑使用观察者模式。
   一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。
   观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。
   事件委托：一个委托可以搭载多个方法，所有方法被依次唤起；委托对象所搭载的所有方法必须具有相同的原形和形式，
   也就是拥有相同的参数列表和返回值类型。
   
    按照“四人团”的说法，Observer模式的意图是“定义对象间的一种一对多的依赖关系，
    当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新”。
   实际应用的例子是，比如建模工具中，若干条线形元素附着在一个块状元素上，当块状元素的大小、位置发生变化，那些线形元素也需要进行改变，
   这个时候我们就可以应用Observer模式，在块状元素和线形元素之间建立一对多的关系，并利用这一模式进行维护。
   Observer模式首先构造一个Observer类，在这个类中具有一个update函数。被依赖的对象拥有它，依赖的对象被注册到Observer中，
   当被依赖的对象发生变化的时候，就调用update函数更新所有依赖它的对象。更新的方式由update函数具体实现。
   还有一个现实中的例子，各个部门之间进行通讯，当一方发出新的信息时，按照传统的方法它必须告诉所有其他部门。
   如果使用Observer模式，那么产生新消息的一方只需要告知Observer，由Observer通知其他方面。
   
2. 观察者模式的优点：
   1. 观察者和被观察者之间是抽象耦合。增加观察者还是被观察者都非常容易实现，只需实现相应的接口。
   2. 可以建立一套触发机制。
   3. 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知，方便管理。
   
3. 观察者模式有下面的一些缺点：
   1. 如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。（客服电话）
   2. 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式时要特别注意这一点。
	 （B1->A1->B2->A2->B1）B:被观察者A：观察者
   3. 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。（java线程）
   4. 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。
   