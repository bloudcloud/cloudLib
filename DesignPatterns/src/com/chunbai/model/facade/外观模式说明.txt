Facade外观模式，是一种结构型模式，它主要解决的问题是：组件的客户和组件中各种复杂的子系统有了过多的耦合，
随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。
在这里我想举一个例子：比如，现在有一辆汽车，我们（客户程序）要启动它，那我们就要发动引擎（子系统1），
使四个车轮（子系统2）转动。但是实际中我们并不需要用手推动车轮使其转动，我们踩下油门，此时汽车再根据一些其他的操作使车轮转动。
油门就好比系统给我们留下的接口，不论汽车是以何种方式转动车轮，车轮变化成什么牌子的，我们要开走汽车所要做的还是踩下油门。

GoF《设计模式》中说道：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
我就上面说的那个情形写一下实现代码，首先我们要实现三个子系统（Wheel、Engine、Body）：
正如上面所说：客户端代码（Program）不需要关心子系统，它只需要关心CarFacade所留下来的和外部交互的接口，
而子系统是在CarFacade中聚合。

外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，
这个接口使得这一子系统更加容易使用。（非常简单，而且常用）
幕后处理的Adapter模式，是利用组合的方式将所有的子类操作集合在一个“公共接口”就是对外更加简明的方法，
还以“替_考”为例，在实施“替_考”的过程中，很显然不能直接写卷子的，还有些事要做……

Façade模式的几个要点：
1. 从客户程序的角度看，Facade模式不仅简化了整个组件系统的接口，同时对于组件内部与外部客户程序来说，
   从某种程度上也达到了一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。

2、Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。
外观模式是软件工程中常用的一种软件设计模式。它为子系统中的一组接口提供一个统一的高层接口。使用子系统更容易使用。   
结构
　　Facade 　　这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口 　　Clients 　　
客户对象通过一个外观接口读写子系统中各接口的数据资源。 　　Packages 　　客户可以通过外观接口读取的内部库。

Facade模式的目的就是给子系统提供一个统一的接口。现在的软件都是按照模块进行划分，对不同的模块分别进行编程。
但是在用户开来，不同的模块应该具有统一的接口，换句话说，我们应该可以通过统一的接口访问系统中的所有功能。

    有一个很典型的例子就是编译系统。通常我们将编译系统分解为：Compile和Link两个步骤。
    一个Compile又可以分解为词法分析、语法分析、语义分析、中间代码生成等等步骤。对于用户来讲，
    我们不可能将这些模块分别提供给他们，让他们依次调用。相反的，我们应该提供一个统一的接口，
    使得用户可以方便的使用各个功能，例如IDE 。

    Facade模式在强调模块化开发的同时也强调模块的统一，统一的接口也有利于子系统中模块内部的变化。
    对于开发大型系统来说，Facade模式是不可缺少的。
外观模式 
外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 

要点： 
1． 外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。 
2． 外观模式实现了子系统与客户之间的松耦合关系。 
3． 外观模式没有封装子系统的类，只是提供了简单的接口。如果应用需要，它并不限制客户使用子系统类。因此可以在系统易用性与通用性之间选择。 
4． 外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。 
5． 外观模式经常使用单例实现，但子系统们可以有多个Façade。 

设计原则： 
最少知识原则：只和你的密友谈话 
1. 实现子系统的功能。 
2. 子系统可以由Façade调用，也可以由Client直接调用。 
3. 子系统不知道Façade的存在，对于子系统，Façade只是一个Client。 

协作： 
1. 客户程序通过发送请求给Façade的方式与子系统通讯，Façade将这些消息转发给适当的子系统对象。 
2. 使用Façade的客户程序不需要直接访问子系统对象。 

适用性： 
1. 为一个复杂子系统提供一个简单接口。 
2. 减少子系统之间以及子系统与客户端的依赖性，提高子系统的独立性和可移植性。 
3. 在层次化结构中，可以使用Facade模式定义系统中每一层的入口。简化各层之间的依赖。
