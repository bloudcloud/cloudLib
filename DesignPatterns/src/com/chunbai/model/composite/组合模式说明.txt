组合模式方便于我们处理递归以及分级数据结构。组合模式用于这些数据结构效果显著，如经常面对计算机的文件系统，
文件系统由目录和文件组成。目录之中可以使目录，也可以使文件，因而计算机的文件系统由递归结构组织而成。
如果想编程表示这一数据结构，就可以使用组合模式。

组合模式具有下列几种元素组成：
1. 元素接口： 针对于所有成员元素的公共接口。
2. 叶子元素： 代表数据结构中终端元素的类。文件系统中文件就是叶子元素，它们没有孩子节点。叶子元素必须实现元素接口。
3. 组合元素： 数据结构中表示一个集合的类。文件系统中目录就是组合元素。组合类必须实现元素接口。

Composite模式的意图是“将对象组合成树形结构表示‘整体-部分’的层次结构。
Composite使得用户对单个对象和组合对象的使用更具有一致性”。

在Word中我们经常会将一些图元进行“组合”，组合以后的图形还可以向简单图元那样进行移动、变形等等操作；
除此以外，在Word中，我们对于一个字符、一个词组、一句话、一个段落，甚至是整篇文章的操作是相同的，
我们都可以进行剪切、复制，进行字体与大小的调整，进行颜色的变换。这些例子都是Composite模式的实例，
我们将简单的元素组合成复杂的元素，然后还可以像操作简单元素那样操作组合元素。

Composite模式将子元素组织成树型，实际上，组织成图型也没有问题。用户总是喜欢组合简单元素，
一方面，用户可以通过这样的组合来进行抽象，另一方面，用户可以通过组合化简繁琐的操作。
Composite模式在各种可视化编辑软件中应用得最为广泛。

另一使用Composite的经典例子是Java的Swing系统。所有的Swing组件都是继承自一个叫做JComponent的接口，
因此，我们对一个JFrame的操作和对一个JButton的操作是一样的。这同时也使得，JFrame在管理自己的子元素时，
它不需要知道他们是一个JButton还是一个JPanel，对它来说，这只是一个JComponent。

实现Composite模式的关键是良好设计的接口，人们应该对可能的元素（简单的、组合的）进行分析，
并设计出通用的操作。尽可能的保证接口操作对所有元素都是有意义的，否则就应该将那些只对部分元素有意义的操作下放到子类中。

组合模式中的元素，无论是叶子还是组合元素都必须是可以互换的。也就是说它们拥有一个公共接口。
当然我们不可能对组合模式的所有应用都找到相同的一个公共接口，但至少这个公共接口必须像一个集合。

组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，
客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。 　　
组合模式让你可以优化处理递归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。
关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的:文件系统。文件系统由目录和文件组成。
每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。
如果你想要描述这样的数据结构，那么你可以使用组合模式Composite。 　　

“组合模式方便于处理递归以及分级数据结构。例如：计算机的文件系统，文件系统由目录和文件组成。目录之中可以是目录，也可以是文件。
因而，计算机的文件系统由递归结构组织而成。如果想编程表示这一数据结构，就可以使用组合模式。”
组合模式有三种元素：元素接口、叶子元素（即文件）、组合元素（即目录）。叶子和组合都实现同一个接口，例如 ↓↓
以上只是举个例子，请根据实际情况考虑。之所以让叶子和组合实现相同的接口是因为这样可以以相同的方式对待所有的元素。
例如我们平时所用到的移动文件，复制文件什么的，这些操作对于叶子（文件）还是组合（文件夹）都是相同的，
只要保证了它们的接口相同，就可以相同的对待。而不同的有例如组合（文件夹）可以加减 item，而叶子（文件）不可以等。
这些可以通过它们接口方法的各自实现不同来做到，像上述接口中的 addItem()，
在组合里就是加 item 的相关操作，而在叶子里就是空的，来实现叶子不能加 item 的效果。

书中的例子是构建了一个简单的文件系统。这个小例子写下来，内容还是挺丰富的，但是说倒不好说了，且请看案例。
从这个例子我倒学了一样不大相干的，之前说通过事件传递数据，我就知道自定义事件，现在发现有时候还可以用另外一种的。
就是通过 event.target 或者 event.currentTarget。需要的时候，在这些各种target的类里写一个 get data 的 getter 方法。
然后返回所需要传递的数据，最后通过 event.target (或 currentTarget ) .data 点出来就可以了。
好吧，也许这本来应该是最基本的东西，反正我是现在才学会啊！ 而且竟然还有 xml.children() ！
另外还有 delete 关键字。这让我意识到一个问题，
是不是所有被创建过的属性方法以及动态生成的变量引用最后在不要的时候都要=null或者delete掉… 这个也，呃，好吧，没事了。
关于 delete 有相关链接 → http://hi.baidu.com/lucklookl/blog/item/e347ae078457287203088179.html
觉得这章还挺多东西的，可是说下来就这么一点么，而且还没说到重点上，哈哈。这个真的不好解释嘛，看代码看代码去！
另外，本文重点在于本文第一句！

定义(GoF《设计模式》)：将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和使用具有一致性。 
涉及角色： 　
　1.Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 　
　2.Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。 　
　3.Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。 　　 　　

适用性 　　
以下情况下适用Composite模式： 　　
1．你想表示对象的部分-整体层次结构 　
2．你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 　　


总结 　　
组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以向处理简单元素一样来处理复杂元素。 　
　如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。
本章使用了一个文件系统的例子来举例说明了组合模式的用途。在这个例子中，文件和目录都执行相同的接口，这是组合模式的关键。
通过执行相同的接口，你就可以用相同的方式对待文件和目录，从而实现将文件或者目录储存为目录的子级元素。 

组合模式：允许你将对象组合成树型结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 

要点： 
1. 组合模式以不遵守单一责任原则换取透明性，让Client将组合和叶节点一视同仁。 
2. 在实现组合模式时，有很多设计上的折衷。要根据需求平衡透明性和安全性。 
3. 有时候系统需要遍历一个树枝构件的子构件很多次，这时候可以把遍历结果缓存起来。 
4. 组合模式的实现中，可以让子对象持有父对象的引用进行反向追溯。 
适用性： 
以下情况使用Composite模式: 
1. 你想表示对象的部分-整体层次结构。 
2. 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 
优点： 
1. 组合模式可以很容易的增加新的构件。 
2. 使用组合模式可以使客户端变的很容易设计，因为客户端可以对组合和叶节点一视同仁。 
缺点： 
1. 使用组合模式后，控制树枝构件的类型不太容易。 
2. 用继承的方法来增加新的行为很困难。