适配器模式属于Gof(Gang of four)在《设计模式》中提到的23种设计模式之一.
可能是"替_考"是过滤词，发表不了
万能钥匙Adapter模式，可以将一种接口转化为另一种接口，以方便相同的场合对不同的接口的统一，最常见的例子就是“替_考”。
 OK,来玩个替_考,怎么你没被人_替_过？嘿嘿，这“_谁_”又知道呢，哈哈。
本例是简化版的，实际上TiKaoAdapter中传入的参数应该是ITiKao接口，实参就是实现了ITiKao接口各个_替_考者，活学活用。

我要一碗汤，但是只有纸饭盒，还没勺，所以食堂的师傅给了我一次性的汤碗和勺，这叫适配器。 
适配器解决的是某一个类的对外接口不合用的问题，可能是参数或者返回值类型不符等问题造成的，
这时候我们需要在工作对象和这个类之间加一层间接的层次。
这个模式我在底层的数据交换层用过。我说过，flash和asp.net之间交换数据全以xml为载体。
返回xml在底层只有三层，数据库操作，数据操作，数据显示，由数据操作层返回给数据显示层一个xml字符串就可以了。
然后我就遇到一个小问题，在另一方面，我需要提交数据到数据库，也是提交一个 xml字符串，
但是我需要数据库里对应的表的数据集的xml表现形式的xsd验证！（一口气说完，差点没憋死）。
就是说我至少需要取出这个表里的一条记录，问题在于，我封装的类从来只返回xml，没有返回xsd的。
解决办法就是适配器，新建一个项目，加了一层专用于获得xml验证格式，这样就完成了不同接口之间的转换。

备注：适配器和桥接很象，都是在已有类不符合要求的时候，加入一层间接的元素以达到目的。
不同的是适配器是解决不兼容接口之间的转换，桥接一般不涉及这个问题，只是完成一个一对多的转换。
Adapter模式的概念
在大规模的系统开发过程中，我们常常碰到诸如以下这些情况：
我们需要实现某些功能，这些功能可以利用已有的一个或多个还不太成熟的组件或类，如果我们自己重新开发这些功能会花费大量时间；
所以很多情况下会选择先暂时使用组件，以后再考虑随时替换。
但这样一来，会带来一个问题，随着组件库的替换，可能需要对引用该组件的源代码进行大面积的修改，因此也极可能引入新的问题等等。
如何最大限度的降低修改面呢？
Adapter模式就是针对这种类似需求而提出来的。
Adapter模式通过定义一个新的接口（对要实现的功能加以抽象），和一个实现该接口的Adapter（适配器）类来透明地调用外部组件。
这样替换外部组件或改写类时，最多只要修改几个Adapter类就可以了，其他源代码都不会受到影响。
Gof在《设计模式》中提到了两种Adapter适配器模式，一种叫对象适配器模式，另一种叫类适配器模式。
*对象适配器模式提倡通过复合(Composition)来实现适配器模式
*类适配器模式提倡通过继承(Inheritance)来实现适配器模式

适配器模式中的有以下的四种角色：
　　目标(target)：定义客户端使用的与特定领域相关的接口。
　　被适配者(adaptee)：定义了一个已经存在的接口，这个接口需要匹配。
　　适配器(adapter):对Adaptee的接口与target的接口进行适配。
　　客户端(Client)：与符合target接口的对象协同。
下面，我通过我的一个例子来解说这几个角色。见以下范例，（范例改编自《OReilly.ActionScript.3.0.Design.Patterns》一书）。

如上范例中，ITarget即为接口，Main为文档类即客户端，Adaptee为被适配者，AdapterA和AdapterB为适配器.
其中，AdapterA是以类适配器模式实现的,AdapterB是以对象适配器模式实现的。
综合在开发中复合多与继承的情况，对象适配器模式比较易用一些，至于使用复合多与继承的的原因，我准备在以后的blog中讨论这个问题。

•适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一 起工作。
•系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。
适配器模式主要应用于希望复用一些现存的类， 但是接口又与复用环境要求不一致的情况。
•在双方都不大容易修改的时候再使用适配器模式适配。

适配器，简单来说，就是对一个已知类再封装一下，使其能完成相似的功能的同时又满足某种规范（接口）。
一个最简单的适配器需要涉及到三个类：已有类Adaptee、适配器类Adapter、满足的目标接口ITarget。
《actionscript3设计模式》中有个例子可以帮我们很好地理解适配器。
汽车驾驶适配器（P189）：
有一个汽车类 Car，它有两个公有方法：
public function start():void;    //汽车启动
public function setSteeringWheelAngle(nAngle:int):void;    //方向盘，可根据输入的角度转动汽车的方向
这个汽车里就是适配器模式中的“已有类Adaptee”。
现在有一个需求，我们不想用方向盘控制车的方向了，而想改用键盘上"↑↓←→"等方向键来控制。于是，有了一个目标接口ICar：
function start():void//启动
function goStraight():void//向前
function turnRight():void//转右
function turnLeft():void//转左
这是适配器模式中的ITarget。
接下来，就是根据ICar接口来重新封装Car类的适配器CarAdapter：
public Class CarAdapter implements ICar{　　
private var _car:Car = null;
private var _nAngle:Number = 0.0;

	public function CarAdapter(car:Car){
	    _car = car;　
	}
	
	public function start():void{ 
	    _car.start(); 
	}
	　
	public function goStraight():void{ 
	    _car.setSteeringWheelAngle(0); 
	}
	
	public function turnRight():void{ 
	    _car.setSteeringWheelAngle(90); 
	}　　
	
	public function turnLeft():void{ 
	    _car.setSteeringWheelAngle(-90); 
	}
}
该适配器类利用Car类原有的setSteeringWheelAngle方法，按照ICar接口规范，封装成实现功能相近的转向功能，这就是适配器模式。
这个例子用到的是对象未作参数传入的对象适配器。
此外还有类适配器，直接继承已有类和规范接口进行扩展。道理相同，都是把已有类进行封装，使其实现了相近的功能又满足接口。
不过面向对象设计中提倡组合，总体来说，组合比继承更灵活。

 有一天你在网上找到一个库，你打算把它应用到你的程序当中去，但是你发现这个库的函数不符合你的风格，你会怎么办？
 一个很简单的方法就是使用Adapter模式。
    Adapter模式的目的就是将一个类的接口转换为用户希望的接口，使得由于接口不兼容而不能一起工作的各个类可以一起工作。
    例如在一个软件里面可能使用了以前一个版本的类库。不幸的是这个类库的效率极高却和现在的接口不兼容，
    为了继续复用这个类库我们就可以使用Adapter模式，在原来的类库和现在的接口中间实现一个适配器，使得我们可以用现在的结构调用以前的类库。
    例如一个绘图程序（这种事情总是出现在这类程序中），以前的类库中提供绘制直线的方法DrawLine，
    但是新的接口要求绘图系统还要提供绘制矩形、折线形的方法，为了复用这个类库，我们实现一个Adapter类，
    这个类中利用以前的绘图系统提供的方法实现了新的接口功能。

适配器模式
Adapter（别名Wrapper）模式：将一个类的接口，转换成客户期望的另一个类的接口。
适配器让原本接口不兼容的类可以合作无间。 
要点： 
1． 适配器模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，
在遗留代码复用、类库迁移等方面非常有用。 
2． 适配器模式有对象适配器和类适配器两种形式的实现结构，但是类适配器采用“多继承”的实现方式，
带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。 
适用性： 
1. 系统需要使用现有的类，而此类的接口不符合系统的需要。 
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，
包括一些可能在将来引进的类一起工作。这些源类不一定有很复杂的接口。 
3. （对对象适配器而言）在设计里，需要改变多个已有子类的接口，如果使用类的适配器模式，
就要针对每一个子类做一个适配器，而这不太实际。 
效果及优缺点： 
对于类适配器： 
1. 用一个具体的Adapter类对Adaptee和Taget进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类Adapter将不能胜任工作。 
2. 使得Adapter可以override（重定义） Adaptee的部分行为，因为Adapter是Adaptee的一个子类。 

对于对象适配器： 
1. 允许一个Adapter与多个Adaptee，即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。
Adapter也可以一次给所有的Adaptee添加功能。 
2. 使得override（重定义）Adaptee的行为比较困难。如果一定要override Adaptee的方法，
就只好先做一个Adaptee的子类以override Adaptee的方法，然后再把这个子类当作真正的Adaptee源进行适配。