 实例1：
 1，状态模式允许一个"对象"在其内部状态改变的时候改变其行为。
2，状态模式的角色：
抽象状态，具体状态（一般是几个，每一个状态下有不同的行为，），
环境(context)角色（就是对象，什么对象的状态，一般该对象要初始化一个状态，还有改变状态，还有该状态下的行为）
我们打篮球的时候运动员可以有正常状态，不正常状态，和超常状态，现在我们就以我们打篮球时候投篮时候的状态来举例子，
 这个是本书介绍的最后一个模式了。状态模式会用于当一些对象拥有很多状态的时候，
 例如说一个按钮它有很多个功能，每点一下就切换一个功能，那这个按钮就有好几种状态了。
 再比如一个篮球射手，他有可能是投了个两分、或者罚球、又或者是三分，也就说这个篮球射手他有三种状态。
在状态模式里面，把每一个状态都封装了起来，这个实现的方法有很多。可以通过状态接口实现，也可以通过继承抽象状态类来实现，
这个应根据实际的需求来决定。另外还会有一个状态机，状态机是用于管理状态的。
之前说的状态类一般是internal型的，因为只有状态机可以用它。而状态机呢，是对外的，也就是说外部跟状态机说我要怎样怎样，
然后状态机在自己的内部选择好所需要的状态并且把结果返回。

总的来说状态模式是用以解决一些对象拥有多种状态的问题。状态模式把这些状态的更换以及管理封装了起来，并且还封装了各种状态，
以便于管理和应用。而对于状态的创建和销毁也有两种，一种是new一次保存引用，而另一种就是需要的时候就new。
各有利弊，同样是看实际的需求以及项目的大小来决定。

相对来说状态模式的灵活性还是挺高的，规范了那些多种状态对象的管理以及实现。

 State模式：这个模式的意图是允许对象在其状态改变时修改其行为，好像对象改变了。
 这个模式的应用场景是当对象的行为依赖于对象的状态时。为了实现这个模式，我们可以为每个状态下的行为实现一个类，
 当对象的状态发生改变，它调用不同状态对象的实例方法。
 注意，以前可能需要使用switch或者if语句进行分支转换，现在则利用多态机制完成。
 今天扯一下 状态模式  一般程序改变对象状态时。大家普遍喜欢通过判断语句的条件来判断对象的状态变化。
 这样写不是不行。如果简单的对象状态判断还是行的。复杂点的话一旦有点需求更改。改动的代码肯定是很恐怖的。
 所以状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。
 把状态的判断逻辑转移到表示不同状态的一系列类当中。这样写程序易于扩展和维护。
 当然坏处就是代码量上来了。妈的。我发现只要易维护的程序。代码量一般都不少。
 这也是松耦合的代价吧。我认为这个模式还是先定义一个状态接口。各个状态实现该接口。
 主要每个状态要拥有控制类的引用。当然控制也要有状态类的一个应用。当需要改变状态时。
 状态类把下一个状态类的应用传递个控制类。控制类再调用接口方发放予以触发下一个状态。
..
我今天想吃面，师傅问我：要什么料？西红柿鸡蛋，排骨还是牛肉？ 
举例：状态模式是指将对象当前的某些状态局部化，当对象改变状态时，看起来好像改变了类。
例子还是我的滚动条。如果要滚动的是文本框，就要引用一个 TextField的Scroll,maxscroll属性，
如果是mc，引用的是_y,_height属性，我用一个参数将二者区分，由一个if语句控制，让滚动条可以自由区别状态。
另外一个解决方案是定义ScrollBar的不同子类，这两者本质区别不大，在状态比较多时，
可能要维持一个庞大的if算法，这样就用生成子类的方法比较好。

状态模式 
状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 
要点： 
1． 策略模式和状态模式是双胞胎，它们有相同的类图，但是它们的意图不同。
策略模式是围绕可以互换的算法来成功创建业务的,然而状态模式是通过改变对象内部的状态来帮助对象控制自己的行为. 
2． Context将与状态相关的操作委托给当前的Concrete State对象处理。 
3． Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context。 
4． Context或Concrete State类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。
也就是说可以在State中保存对Concrete State的引用，在必要时设置具体的状态，做到状态的转换。 
5． 一般来讲，当状态转换是固定的时候，状态转换就适合放在Context中。
然而，当转换是更动态的时候，通常会放到具体的状态类中进行。（具体状态类持有Context的引用，实现状态的转换） 
适用性： 
1. 一个对象的行为取决于它的状态 , 并且它必须在运行时刻根据状态改变它的行为。 
2. 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。
通常，有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一独立的类中。
这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 

效果： 
1. State模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。 
State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中,
 所以通过定义新的子类可以很容易的增加新的状态和转换。 
另一个方法是使用数据值定义内部状态并且让Context操作来显式地检查这些数据。
但这样将会使整个Context的实现中遍布看起来很相似的条件语句或case语句。
增加一个新的状态可能需要改变若干个操作，这就使得维护变得复杂了。 
State模式避免了这个问题,但可能会引入另一个问题,因为该模式将不同状态的行为分布在多个State子类中。
这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些 , 
否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。
它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。State模式提供了
一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的 if或switch语句中, 
而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，
就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。 

2. State对象可被共享。如果State对象没有实例变量，即它们表示的状态完全以它们的类型来编码，
那么各Context对象可以共享一个 State对象。

