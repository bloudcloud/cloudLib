抽象工厂是实例1：
继承于抽象工厂类的工厂们创建出了实现产品接口的产品

反射工厂是实例2：

抽象工厂与反射工厂
抽象工厂的局限性在于，它没法消除new这些碎片耦合部分，而new碎片散落在客户端上，堆积到一定程度就出现坏味道，甚至出现维护问题，不容易修改，
而通过反射机制可以缓解这种new碎片散落程度。
如果要优雅地解耦，必然要使用框架，据我所知AS3是有其支持的框架的，由于种种问题，本人没有研究过AS3的框架，
不过通过AS3自身的反射机制可以模拟一个解释器去到达最大限度解耦。

语,对于抽象工厂我就不多解释了，反射工厂就有几点补充，可以看出，反射工厂没有在代码区域耦合一点的实现代码，
都是通过抽象层面去交互，而也是它取代抽象工厂的原因，而不好的地方是要预先引入产品实体类，这个其实也是不得不做的，
根源是AS3的机制问题，而这一点不影响区别两种工厂的优缺点。反射工厂的优势是把变化隔离出外部文件，
而消除了具体对象使用的判断逻辑，没有new碎片了，而这是抽象工厂无法做到的，抽象工厂无法摆脱这些判断，而这些判断必然会导致耦合加深，
终究会出现new去生成对象。简短例子，希望对你有帮助。

 一开始，我是冲着工厂模式来的，带着对工厂模式的无限憧憬翻开了书。
 因为听GR说了好些次，很想知道它到底长了什么个样。好吧，事实上是有点小失望啦。因为书里的这章讲的只能说是一个概念罢了。
 只是模板方式对我来说还是学到一点点东西的，虽然其实也是很简单的东西。之前不能说完全没有遇到过，只是自己还不会把东西抽象成型出来。
 对的，没错，这一章就是为了讲所谓的抽象才标了工厂的题。

这是一个抽象类。抽象类就是用以被继承咯。先看initialize()里面说明了一步接一步的该干些什么，即调用什么方法。
而被调用的方法，也就是实际要完成任务的部分是空的，用以被子类继承后覆写。这里的initialize()就像是一个模板，
故称此为模板方法。所有的子类先去拿一套模板过来先（即继承），然后根据自己的实际情况去填充（即覆写）。
而这个模板是不能被子类所更改的，所以initialize()函数前有final关键字。老实说，我也把它给忘了。哈哈哈哈。
没用过啊，没办法。然后再翻下黑老大的书，好吧，殿堂真的是什么都有的！
所谓final，也就是说不能被覆盖，final，final，就是最后嘛，说明标注的这个函数就是最终版本了，那当然就不能被覆写咯。

我觉得这个方法也挺直观的。就是模板嘛，跟平时用的模板一样呀，自行想象下便是。哈哈。
而里面的抛出Error，个人觉得是为了避免漏掉覆写而加上去的。因为毕竟override不像接口，接口里的方法没有实现是会报错的，
而覆写的话，是不会要求你一定要覆写的。因此设置了抛出错误用以提示。模板方法模式最基本的大概就是这些了吧。

至于工厂方法么。我真的不知道书上说的到什么程度了。我觉得它介绍的就是接口的用法啊。
 还有的就是创建一个抽象类，然后让子类具体实现。搞半天这书里讲的工厂模式就是各种抽象的应用 ←其实只说了两种。
 我又不知道它说的对不对，或者说到什么程度了。所以，还是等以后学习多点再看下怎么样吧。

这个模式的关键就是设计一个AbstractFactory接口，这个接口提供了一系列抽象函数用来创建各种对象。
这个模式的意图就是使用一个统一的接口用以创建不同具体对象。
假设这样一个场景，在不同配置的计算机上完成显示和打印任务，对于高配置的计算机我们使用高分辨率的驱动，
在低配置上的机器使用低分辨率的驱动。这个时候，我们可以将显示驱动看成ProductA，打印驱动看成ProductB；
每种驱动具有两种分辨率，分别对应高低两种配置。这个时候在创建（配置）系统驱动的时候，
我们就可以使用AbstractFactory模式，为高低两种配置实现两个具体工厂类，分别用于创建对应的驱动。
所有的用户不用关心当前是什么配置的计算机，它只需要调用统一的抽象工厂接口就可以获得对应的驱动。
使用这个模式还需要注意的是，产品对象也必须具有良好的设计，以至于用户不需要关心具体的产品是哪种类型就可以
通过抽象产品的接口使用这个产品。使用这个模式可以令用户无需关心具体环境，降低代码耦合度，使得程序结构更加清晰。
缺陷是当每个产品的具体实现有很多种时，实现的具体工厂类的数量会迅速膨胀，而且它不能对环境的改变进行立即响应。
