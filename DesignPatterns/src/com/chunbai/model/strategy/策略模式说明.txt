今天继续扯淡研究策略模式 我认为策略模式 是一种升华下的简单工厂模式 因为策略模式就是封装了算法。在不同的情况下调用不同的算法。
而这样的需求简单工厂模式也能办到。但如果这样客户端代码有可能需要持有2个类的应用 这样就增加了耦合度。
而用策略模式+简单工厂模式的组合只需要一个类。这样易于维护和管理。这回还是一样 大部分时间又耗到了ASwing上。
这回用到了传说中的Form 其中对FormRow的setColumnChildrenIndecis（）方法还是有点蒙。在研究了。

本篇是接“oo设计模式初学－龟兔赛跑”中使用到的伪strategy pattern模式来完整实现原计划游戏，
类于梦幻西游中小龟赛跑游戏，
还有太阁立志传学习马术（吃胡萝卜疾风飞车那代）游戏，深入了解将接口应用在startegy pattern模式
上多态实现（龟加速、兔子加速，龟减速，兔子减速），
考虑到一个完整的游戏需要事件的支持，但又不想与observer发生概念误差，
所以兔子与龟的奔跑放在Race.as（文档）中实现，原本应该是他们自己接收事件，执行奔跑。


策略模式：
    策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现得不同，
    它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
    如果不理解多看看代码，对于简单工厂模式不理解的，可以看我前面的帖子：简单工厂模式 

策略模式的组成
　　—抽象策略角色： 策略类，通常由一个接口或者抽象类实现。 　　
—具体策略角色：包装了相关的算法和行为。 　　
—环境角色：持有一个策略类的引用，最终给客户端调用。   策略模式UML图

编辑本段概念
　　策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
（原文：The Strategy Pattern defines a family of algorithms,encapsulates each one,and makes them interchangeable. 
Strategy lets the algorithm vary independently from clients that use it.） 　　

Context(应用场景): 　
　1、需要使用ConcreteStrategy提供的算法。 
　　2、 内部维护一个Strategy的实例。 　
　3、 负责动态设置运行时Strategy具体的实现算法。 　
　4、负责跟Strategy之间的交互和数据传递。 　

　Strategy(抽象策略类)： 　　
1、 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，Context使用这个接口调用不同的算法，一般使用接口或抽象类实现。 　
　ConcreteStrategy(具体策略类)： 　
　2、 实现了Strategy定义的接口，提供具体的算法实现。
编辑本段应用场景
　　应用场景： 　　1、 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。 　
　2、 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 　
　3、 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。

优缺点
优点： 　　
1、 提供了一种替代继承的方法，而且既保持了继承的优点(代码重用)还比继承更灵活(算法独立，可以任意扩展)。 
2、 避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展。 　　
3、 遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。 　　
缺点：
1、 因为每个具体策略类都会产生一个新类，所以会增加系统需要维护的类的数量。
 Strategy模式的目的就是“定义一系列的算法，把他们一个个封装起来，并且使他们可以互相替换。”
 如何理解这一模式，首先看下面这个场景：一组数据进行排序，我们可以选择很多中排序算法，
 这个时候我们定义一个排序策略，然后每个排序算法实现一个具体策略，这样用户就可以在几个不同的排序算法中随意选择和替换了。
    当然，上面的例子中使用策略模式似乎多此一举，那么假设游戏中的敌人的AI，
    根据玩家的设定可以有不同的级别。在这种情况下，使用策略模式就是十分必要的了。
实例2：
为什么不写入到具体的类里呢？
这些是变化的东西需要从duck基类中抽出来，具体类在实现，但是这些变化的东西在具体类中又有重复，
比如橡胶鸭子也会叫，野鸭子也会叫，如果他们的叫声是一样的，那就可以重用。我的想法是这样子的。
所以就用你说的不是针对实现而是针对接口。

橡胶鸭子叫是委托quackBehavior的quack()
野鸭子叫也是委托quackBehavior的quack()
在子类中只要指定quackBehavior.因而把quackBehavior做成一个接口类，
让它的子类都实现quack()方法，而每个子类就可以在quack()中实现不同的quack方法 嘎嘎 呱呱 唧唧 都是可以了

我每天先在食堂找座位，再打饭，再打菜，再买杯酸奶。这已经模式化。要是食堂有服务员，我也会要他这么做。 
举例，策略模式是把一系列的算法封装起来，形成一个类。这个模式几乎是随时随地都可以整合到别的模式里去的，
我的那一堆xml解析器实际上就是策略模式的应用，这个模式还应用到我网站的下层，
因为flash提交给aspx页面的数据也是xml字符串，下层模块也需要相应的解析算法。
同样的，我把对xml的解析封装进了一个类。

//Cs文件里的解析函数
 
Class DataModel.BlogMsgs{
    …
    Public DataSet parseXML(string strXml){
    DataSet ds=new DataSet();
    //。。把xml装载到DataSet 里
    Return ds
    }
    …
}
