Builder模式的缘起：
    假设创建游戏中的一个房屋House设施，该房屋的构建由几部分组成，且各个部分富于变化。
    如果使用最直观的设计方法，每一个房屋部分的变化，都将导致房屋构建的重新修正.....
动机（Motivation):
    在软件系统中，有时候面临一个"复杂对象"的创建工作，其通常由各个部分的子对象用一定算法构成;
    由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合到一起的算法却相对稳定。
    如何应对种变化呢？如何提供一种"封装机制"来隔离出"复杂对象的各个部分"的变化，
    从而保持系统中的"稳定构建算法"不随需求的改变而改变？
意图(Intent)：
    将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
                                              -------《设计模式》GOF
适用性：
    1.当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
    2.当构造过程必须允许被构造的对象有不同的表示时。

Builder模式的几个要点:
Builder模式 主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的乘法，而复杂对象的各个部分则经常变化。
Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。
Abstract Factory模式解决“系列对象”的需求变化，Builder模式解决“对象部分”的需求变化。Builder械通常和Composite模式组合使用。

Builder生成器模式解决的问题是：“一些复杂对象”的创建工作，子对象变化较频繁，对算法相对稳定

生成器(建造者)模式Builder
Builder模式也是创建型模式中的一种。主要用来应对构成复杂但构成结构和顺序相对稳定的对象的创建工作。
目的是省去在对象发生变化时，需要修改代码中每一处对象创建的地方，应用这种模式，
可以在一个复杂对象的内部结构(由许多其他子对象构成的结构)发生变化时，仅需要对对象有所修改，
而复杂对象与其他的对象之间的关系、行为不需要进行修改。
其实这就是这个创建型模式应用的动机：在软件系统中，有时面临着一个复杂对象的创建工作，
其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，
但是将它们组合在一起的算法却相对稳定。
GOF：
将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。


建造者模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，
通过子类继承和重载的方式，动态地创建具有复合属性的对象。 
优点： 
在建造者模式中，客户端不用在直接负责对象的创建，而是把这任务交给了具体的创建者类；
把具体的如何组装的责任交给了Director类，客户端之负责对象的调用即可，符合单一职责原则。 
缺点： 
1.难于应付“产品构造过程”的需求变动。 
2.创建者模式比较符合产品差别不大的对象的创建，如果差别很大，就会导致非常多的具体的创建者，这时候最好结合工厂方法模式。 
建造者模式的实质： 
解耦组装过程和创建具体部件，使得客户端不用去关心每个部件是如何组装的。 
建造者模式是为了解决复合对象的创建而生的，建造者模式将复杂对象的构建与对象的表现分离开来，
这样使得同样的构建过程可以创建出不同的表现；有利明确各部分的职责目标，有利于软件结构的优化。 
构建产品构造过程（算法或步骤）是不变的，变化的是建造者的部分。 

下面举一个例子，来说明这种应用，比如说买电脑中的装机，根据消费者不同的需求，我们要提供不同品牌不同配置的电脑。
装机器就像Builder模式描述的一样，组装成机器的方法（即用子对象构建对象的算法）是稳定的，
但是根据客户的需求可能对机器现有配置要求升级，则只是子对象发生了变化，但是这不影响极其的组装方法。
定义组装成电脑需要的设备，这里为了代码量少一些，简化了电脑的构建，粗略的分为CPU、主板、内存、硬盘、键盘、鼠标。
首先构建它们对应的抽象类。


4个角色：指挥者(Director)，建造者(Builder)，具体建造者(ConcreteBuilder)，产品(Product)
产品：需要创建的对象产品
具体建造者：创建产品的实例并且实现建造者多个方法对产品进行装配
建造者：本质为抽象类，里面的抽象方法供具体建造者重写，声明产品的引用
指挥者：调用建造者抽象类以及其方法
实现思路：客户端创建一个指挥者，并且实例化需要的产品的具体建造者，然后指挥者调用具体建造者的实例即将产品生产出来。
类图：
应用场景：在Silverlight中我们需要生产一列多行的输入框+TextBlock的组合，但是这些输入框的类型不同，
有一些只能输入256个字符，有的只能输入20个字符，还有的是多行的，有的是单行的输入框。这些输入框的种类是固定的，
但是可能用户自定义输入框的时候我们生成的顺序和各自的生成数量不知道。
分析：在这里产品是固定的，有A,B,C,D,E,F六种输入框+TextBlock，用户可能生成的情况是A,A,C,C,B,B,C、
也可能是B,C,D,B,C,F。这里我们使用建造者模式，这几种输入框基本上都差不多，都是TextBlock+TextBox的模式。
但是可输入数量和是否多行是不定的，那么我们实现AConcreteBuilder,BConcreteBuilder,CConcreteBuilder,DConcreteBuilder,

EConcreteBuilder,FConcreteBuilder等多个具体建造者，然后对于建造者中只需要两个方法分别实例化产品，
并且对产品的属性（可输入字符数、是否可多行）进行设置，然后再用户需要调用什么产品的时候，
使用指挥者调用想要的ConcreteBuilder具体建造者即可。

这一阵子 由于过节和自己工作上扯淡的事情一直没有继续我的扯淡话题。现在好了可以继续了。这回扯得是建造者模式。
建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。例如 我想创建一个做小人的类。
肯定会写 造小人的许多方法。比如 造头 。造腿等等。但是 实际中每个小人都不一样。有胖 有瘦，所以头的大小。胖瘦也不一样。
但是他们肯定会有头和腿。所以我们不要依赖实现编程 而要依赖接口。所以肯定会写好造小人的接口这样 只要胖小人。
瘦小人 实现该接口就行了。当然主要目的还是 构建于表示分离。当然还缺少最关键的一个类。就是指挥者类。
他实际是绝对如果控制造什么样小人的类。虽然胖瘦类 具体实现所有方法。但这不是该类的精髓。
精髓就是 有指挥者类通过对小人接口的应用。来决定一次建造 是建造完整的小人 还是缺胳膊少腿的小人。
来决定真正的构建过程和顺序。说了这么多 可能有点晕

 按照“四人团”的说法，Builder模式的目的是：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。
    一个典型的例子是：文件的格式转换。假设一个RTF文件，我们可以将它转换成不同的格式，比如TXT、DOC、PDF等等。在这些目标格式的文件中，
    有些文件格式中保留文本字体（比如DOC），有些可能不保留（比如TXT）。当我们开始转换过程时，按照RTF文件自己的格式进行分析转换。
    转换的过程是一样的，但是不同的目标文件格式对于不同的转换请求的处理是不同的，比如TXT文件转换将会忽略所有的文本格式控制符，
    但是DOC文件将会把RTF的控制符转换为自己的控制符。应用Builder模式，我们可以实现不同的具体生成器，对于相同的请求产生不同的结果。
    Director负责向Builder发送不同的生成请求，在刚才的例子中，RTF文档的分析器可以看作是Director，
    文档转换器可以看作是Builder。另一个可以想到的例子是一个编成开发环境，我们可能对源程序进行语法分析，
    但是分析的目的可能不同，有的分析可能是用来生成代码，有的可能是用来形成智能感知。
    不论如何，语法分析的过程是相同的，因此将语法分析看成一个Director，代码生成和形成智能感知看作是两个
    ConcreteBuilder，对于相同的分析请求产生不同的动作。例如当分析器发现一个函数以后，就会向Builder发送请求，
    如果这个Builder实例是代码生成器，那么它可能会记录这个函数的入口地址，如果这个Builder实例是智能感知器，
    那么它可能像数据库中插入这个函数的信息。
