方法一：
此方法通过静态私有变量_instance来创建Singleton类的实例，通过getInstance方法来访问这个单一实例。
另外，由于在AS3中不允许private、protected的构造函数，只能是public，因此需要防止用构造函数来创建Singleton类的实例。
这个方法有个问题就是这个类的实例会在程序一开始就创建。


方法二：
此方法通过一个静态私有变量_singleton来控制_instance的创建，保证其唯一性。
并且这个方法不存在方法1中的问题，_instance实例只有在调用getInstance()方法后才会创建。


方法三：
此方法通过对构造函数增加参数来控制单个实例的创建。
此构造函数只有传入参数为私有方法hidden的时候，才能创建实例。
私有方法hidden对外的不可见性保证了单例的实现。


方法四：
此方法和方法3相似,这里利用了包外类对外的不可见性(Singletoner类仅在此as文件内可见)来保证单例的实现。


方法五：
常规写法


1. 单例模式概念
   在面向对象的编程中，要求一个类有且仅存在一个实例，提供一个全局的访问方法,避开构造函数，提供一种机制来实现单一实例，
   这就是单例模式(Singleton模式)。另因为在as3中无法操作线程，因此我们无需考虑多线程情况下的单例。
   单例模式分为懒汉式和饿汉式，懒汉式就是延加载即需要时才创建对象，饿汉式就是定义全局变量时就创建对象；
   对于多线程语言推荐使用饿汉式。

2. 单例模式优点
   实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。
   伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。

3. 单例模式缺点
   系统开销：虽然这个系统开销看起来很小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。
            这个问题可以通过静态实例来解决。
   开发混淆：当使用一个单例模式的对象时开发人员必须要记住不能使用new来实例化对象。当他们发现不能实例化一个类的时候会很惊讶。
   对象生命周期：单例模式没有提出对象的销毁。在提供内存管理的开发语言(如基于.NetFramework的语言)中，
                只有单例模式对象自己才能将对象实例销毁，因为只有它拥有对实例的引用。

4. 单例模式总结
   单例模式的实现方式很多，在不同的需求下选择合适的才是最好的。
   如方法1虽然一开始就会创建实例，但它不会像其他方法每次调用实例都要检查是否存在类的实例。
   单例模式只考虑实例的创建，而没有考虑到销毁，由垃圾回收机制自行处理。
   另外也可以扩展单例模式，如稍做修改保证一个类只有少数几个实例，来实现一些特殊的目的，这样做也是合理和有意义的。

5.  这可能是最简单的一个模式了，但是他的应用却是最多的。这个模式的目的就是保证一个对象只有一个实例，并且提供一个全局的访问点。
    那么这个模式的怎么实现呢？很简单，你首先必须为这个类设置一个指针（Java中是引用），然后提供一个方法用来获得这个类的实例。
    在这个方法中首先判断这个指针是否为空，如果是，则创建一个实例，否则直接返回这个指针。
    虽然我们可以提供一个全局访问点，但实际上这个模式也可以应用到局部。应用这个模式一个好处就是可以“按需分配”，同时也封装了对象的获取过程。
    不论如何，我觉得应该尽可能的应用这个模式，虽然这会让你感到很烦……
    这个模式在实现过程中可以进行变化，例如在Instance()方法上添加参数Boolean bAlloc，用于指定当实例不存在的时候是否进行创建。
    这样做是考虑到，有些时候我们获得实例的目的不是为了修改，而是为了读取。这个时候，返回一个空实例和返回一个没有被修改过的实例在逻辑上是相同的。
    例如，这个对象是一个数组时，一个“空数组”和一个“空白的数组”是相同的。

   