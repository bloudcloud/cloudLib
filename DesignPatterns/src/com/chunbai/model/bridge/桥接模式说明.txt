生活中的一个例子:
    就拿汽车在路上行驶的来说。即有小汽车又有公共汽车，它们都不但能在市区中的公路上行驶，也能在高速公路上行驶。
    这你会发现，对于交通工具（汽车）有不同的类型，然而它们所行驶的环境（路）也在变化，
    
    在软件系统中就要适应两个方面的变化？怎样实现才能应对这种变化呢？
概述:
在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？
如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。

意图:
　　　将抽象部分与实现部分分离，使它们都可以独立的变化。
                                 ——《设计模式》GOF 
              
可以看到，通过对象组合的方式，Bridge 模式把两个角色之间的继承关系改为了耦合的关系，
从而使这两者可以从容自若的各自独立的变化，这也是Bridge模式的本意。
      这样增加了客户程序与路与汽车的耦合。其实这样的担心是没有必要的，因为这种耦合性是由于对象的创建所带来的，
      完全可以用创建型模式去解决。在应用时结合创建型设计模式来处理具体的问题。
应用设计模式:
       桥接模式（Bridge）来做(多维度变化);
       结合上面的例子,增加一个维度"人",不同的人开着不同的汽车在不同的路上行驶(三个维度)(example2);
       结合上面增加一个类"人",并重新调用.

菜太淡，不合有些人的胃口，所以要求食堂的师傅，专门开一个窗口，专门在做好的菜里多加些辣椒。 
我在自己的站里运用了桥接模式：所有的影片都继承自我定义的BasicMovie 类（BasicMovie继承自MovieClip类），
但是在四个下级栏目的影片里，需要定义相同的方法和事件来响应消息，BasicMovie没有这些函数，不符合要求，这时候，在四个影片里都写一遍是愚蠢的，
我又写了一个SubTemplateMovie类继承自BaseMovie，里面加进一些通用的方法，然后四个下级模板影片都继承它，这样大大简化了后期开发。
效果及实现要点：
1．Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
2．所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同汽车。
3．Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。
Bridge模式是比多继承方案更好的解决方法。
4．Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈
——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。

适用性：
   在以下的情况下应当使用桥梁模式：
1．如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。 
2．设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。
3．一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。 
4．虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。

总结：
      Bridge模式是一个非常有用的模式，也非常复杂，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。

桥接模式与装饰的区别:
装饰模式:
      这两个模式在一定程度上都是为了减少子类的数目，避免出现复杂的继承关系。但是它们解决的方法却各有不同，
      装饰模式把子类中比基类中多出来的部分放到单独的类里面，以适应新功能增加的需要，当我们把描述新功能的类封装到基类的对象里面时，
      就得到了所需要的子类对象，这些描述新功能的类通过组合可以实现很多的功能组合 .
桥接模式：
          桥接模式则把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，
          这样就可以实现系统在多个维度上的独立变化 。

       
其实桥接模式就是将高维类的降维处理，
将一件事物本征的东西抽象成不同的类，通过不同的类的组合描述一件事物
其实这与一般的架构设计中要求的模块功能单一化的原则是一致的。

      桥接模式"所解决的问题是将两个维度的变化分离开,使它们可以独立的变化,是采用组合的方式使两个维度联系起来. 
"策略模式"定义一系列的算法,将一个算法封装起来,并让它们可以相互替换.也是应用了组合的方式,根据不同的需要进行组合. 
两者都应用了组合的方式,这也是设计模式的一个原则----组合优于继承.
      桥接模式只是把两个维度的变化给分离,使他们能够沿着各自的维度变化,这才是桥接模式的本意,
      而你所说的并不是桥接模式,它所应用的是组合的方式,和桥接模式中的组合是一个道理.
      “Bridge 模式把两个角色之间的继承关系改为了耦合的关系”

此言不大准确，耦合关系并不是与继承关系并列的，只要具有关系，那么就有耦合，
这里应当是把继承关系转变为关联关系，从而降低了耦合

      桥接模式
最主要的是遵循了：单一职责原则
对吧？
以你的例子，路类，是一个职责
汽车类，也是一个职责
人类，还是一个职责

这三个类的变化不影响其他类，这个就是桥接模式的好处，对不楼主？
  桥接模式主要解决多维度变化的问题。
  按照“四人团”的说法，Bridge模式的意图是：将抽象部分与他的实现部分分离，使得他们可以独立的变化。
  你一定会感到一阵眩晕，不明白这是什么意思。
首先应该说明的是“抽象”与“实现”的含义。在刚才的那句话中，“抽象”与“实现”并不是我们在描述类结构时
所说的“接口”与它的“实现”，或者在Java中抽象类与他的实现。在这里，“抽象”与“实现”只得是某种工作，
“抽象”是说如何完成这项工作，“实现”是说“抽象”中所用的步骤的实现。
一个例子可以很好的说明“抽象”与“实现”的关系。我们编写一个游戏，这个游戏有两个版本，DX版本和OpenGL版本。
我们如何编写这两个版本呢？一种方法是我们在这两个引擎上开发两套独立的游戏，但这显然不是最好的方法。
另一个选择是我们将游戏的“抽象”部分与“实现”部分分离，开发一套“抽象”部分，开发两套“实现”部分。
那么什么是游戏的“抽象”部分？很显然就是游戏的绘图（也许用更专业词汇的应该是：渲染）过程，
例如我们如何渲染游戏的人物，这个人物可能是由很多个多边形组合而成的，我们按照一定的方法渲染之后，
就可以画出一个人物来。这一部分就可以看作是“抽象”。那么另一方面就是“实现”部分，在上面的例子中，
“实现”部分就是如何绘制基础的线条、填充颜色，甚至是初始化屏幕等等。这些“实现”和具体的引擎密切相关。

为什么说我们可以将“抽象”和“实现”分离，使得他们可以各自变化呢？假设现在要开发新的游戏，
或者这个游戏升级了，在其中出现了新的人物，那么“抽象”部分就发生了变化，但是具体“实现”没有变化，
因此这个游戏还可以继续在你的计算机上运行。另一方面，如果游戏需要进行移植，目标平台的图形系统发生了变化，
你可能需要使用新的绘图引擎，这个时候，你只需要利用新的引擎实现基本的“实现”操作，
原始的程序就可以在新的平台上运行（略去重新编译的问题）。   